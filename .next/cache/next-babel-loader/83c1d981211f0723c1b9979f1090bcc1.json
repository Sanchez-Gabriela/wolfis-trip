{"ast":null,"code":"require('dotenv').config();\n\nconst argon2 = require('argon2');\n\nconst postgres = require('postgres');\n\nconst sql = postgres();\nexport async function getPlaces() {\n  const places = await sql`\n    select * from places\n  `;\n  return places;\n}\nexport async function selectUserByUsername(username, password) {\n  const usersWithUsername = await sql`\n  SELECT * FROM users WHERE username = ${username}\n  `; //select from always returns an array, even if its one\n  // console.log(usersWithUsername[0]);\n\n  if (usersWithUsername.length === 0) return usersWithUsername;\n  const passwordMatches = await argon2.verify(usersWithUsername[0].password_hash, password); //this returns boolean\n\n  if (passwordMatches) {\n    return usersWithUsername;\n  } else {\n    return [];\n  }\n}\nexport async function insertUser(username, passwordHash) {\n  return sql`\n    INSERT INTO users (username, password_hash) VALUES (${username}, ${passwordHash})\n  `;\n}\nexport async function selectSessionByToken(token) {\n  return sql`\n    SELECT * FROM sessions WHERE token = ${token}\n  `;\n}\nexport async function deleteSessionByToken(token) {\n  return sql`\n    DELETE FROM sessions WHERE token = ${token}\n  `;\n}\nexport async function insertSession(userId, token) {\n  return sql`\n    INSERT INTO sessions (user_id, token) VALUES (${userId}, ${token})\n  `;\n}\nexport async function insertJourney(startDate, endDate, token) {\n  const userId = await sql`\n    SELECT user_id FROM sessions WHERE token=${token}\n  `;\n  console.log(userId);\n  return sql`\n    INSERT INTO journeys (start_date, end_date, user_id) VALUES (${startDate}, ${endDate}, ${userId}) RETURNING id, start_date, end_date, user_id\n  `;\n}\nexport async function insertEntries(journeyId, placeId) {\n  return sql`\n    INSERT INTO entries (journey_id, place_id) VALUES (${journeyId}, ${placeId})\n  `;\n}","map":{"version":3,"sources":["/Users/gabrielasanchez/projects/wolfis-trip/db.js"],"names":["require","config","argon2","postgres","sql","getPlaces","places","selectUserByUsername","username","password","usersWithUsername","length","passwordMatches","verify","password_hash","insertUser","passwordHash","selectSessionByToken","token","deleteSessionByToken","insertSession","userId","insertJourney","startDate","endDate","console","log","insertEntries","journeyId","placeId"],"mappings":"AAAAA,OAAO,CAAC,QAAD,CAAP,CAAkBC,MAAlB;;AAEA,MAAMC,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMI,GAAG,GAAGD,QAAQ,EAApB;AAEA,OAAO,eAAeE,SAAf,GAA2B;AAChC,QAAMC,MAAM,GAAG,MAAMF,GAAI;;GAAzB;AAGA,SAAOE,MAAP;AACD;AAED,OAAO,eAAeC,oBAAf,CAAoCC,QAApC,EAA8CC,QAA9C,EAAwD;AAC7D,QAAMC,iBAAiB,GAAG,MAAMN,GAAI;yCACGI,QAAS;GADhD,CAD6D,CAG1D;AACH;;AACA,MAAIE,iBAAiB,CAACC,MAAlB,KAA6B,CAAjC,EAAoC,OAAOD,iBAAP;AACpC,QAAME,eAAe,GAAG,MAAMV,MAAM,CAACW,MAAP,CAC5BH,iBAAiB,CAAC,CAAD,CAAjB,CAAqBI,aADO,EAE5BL,QAF4B,CAA9B,CAN6D,CAS1D;;AACH,MAAIG,eAAJ,EAAqB;AACnB,WAAOF,iBAAP;AACD,GAFD,MAEO;AACL,WAAO,EAAP;AACD;AACF;AAED,OAAO,eAAeK,UAAf,CAA0BP,QAA1B,EAAoCQ,YAApC,EAAkD;AACvD,SAAOZ,GAAI;0DAC6CI,QAAS,KAAIQ,YAAa;GADlF;AAGD;AAED,OAAO,eAAeC,oBAAf,CAAoCC,KAApC,EAA2C;AAChD,SAAOd,GAAI;2CAC8Bc,KAAM;GAD/C;AAGD;AAED,OAAO,eAAeC,oBAAf,CAAoCD,KAApC,EAA2C;AAChD,SAAOd,GAAI;yCAC4Bc,KAAM;GAD7C;AAGD;AAED,OAAO,eAAeE,aAAf,CAA6BC,MAA7B,EAAqCH,KAArC,EAA4C;AACjD,SAAOd,GAAI;oDACuCiB,MAAO,KAAIH,KAAM;GADnE;AAGD;AAED,OAAO,eAAeI,aAAf,CAA6BC,SAA7B,EAAwCC,OAAxC,EAAiDN,KAAjD,EAAwD;AAC7D,QAAMG,MAAM,GAAG,MAAMjB,GAAI;+CACoBc,KAAM;GADnD;AAGAO,EAAAA,OAAO,CAACC,GAAR,CAAYL,MAAZ;AAEA,SAAOjB,GAAI;mEACsDmB,SAAU,KAAIC,OAAQ,KAAIH,MAAO;GADlG;AAGD;AAED,OAAO,eAAeM,aAAf,CAA6BC,SAA7B,EAAwCC,OAAxC,EAAiD;AACtD,SAAOzB,GAAI;yDAC4CwB,SAAU,KAAIC,OAAQ;GAD7E;AAGD","sourcesContent":["require('dotenv').config();\n\nconst argon2 = require('argon2');\nconst postgres = require('postgres');\nconst sql = postgres();\n\nexport async function getPlaces() {\n  const places = await sql`\n    select * from places\n  `;\n  return places;\n}\n\nexport async function selectUserByUsername(username, password) {\n  const usersWithUsername = await sql`\n  SELECT * FROM users WHERE username = ${username}\n  `; //select from always returns an array, even if its one\n  // console.log(usersWithUsername[0]);\n  if (usersWithUsername.length === 0) return usersWithUsername;\n  const passwordMatches = await argon2.verify(\n    usersWithUsername[0].password_hash,\n    password,\n  ); //this returns boolean\n  if (passwordMatches) {\n    return usersWithUsername;\n  } else {\n    return [];\n  }\n}\n\nexport async function insertUser(username, passwordHash) {\n  return sql`\n    INSERT INTO users (username, password_hash) VALUES (${username}, ${passwordHash})\n  `;\n}\n\nexport async function selectSessionByToken(token) {\n  return sql`\n    SELECT * FROM sessions WHERE token = ${token}\n  `;\n}\n\nexport async function deleteSessionByToken(token) {\n  return sql`\n    DELETE FROM sessions WHERE token = ${token}\n  `;\n}\n\nexport async function insertSession(userId, token) {\n  return sql`\n    INSERT INTO sessions (user_id, token) VALUES (${userId}, ${token})\n  `;\n}\n\nexport async function insertJourney(startDate, endDate, token) {\n  const userId = await sql`\n    SELECT user_id FROM sessions WHERE token=${token}\n  `;\n  console.log(userId);\n\n  return sql`\n    INSERT INTO journeys (start_date, end_date, user_id) VALUES (${startDate}, ${endDate}, ${userId}) RETURNING id, start_date, end_date, user_id\n  `;\n}\n\nexport async function insertEntries(journeyId, placeId) {\n  return sql`\n    INSERT INTO entries (journey_id, place_id) VALUES (${journeyId}, ${placeId})\n  `;\n}\n"]},"metadata":{},"sourceType":"module"}