{"ast":null,"code":"require('dotenv').config();\n\nconst argon2 = require('argon2');\n\nconst postgres = require('postgres');\n\nconst sql = postgres();\nexport async function getPlaces() {\n  const places = await sql`\n    select * from places\n  `;\n  return places;\n}\nexport async function selectUserByUsername(username, password) {\n  const usersWithUsername = await sql`\n  SELECT * FROM users WHERE username = ${username}\n  `; //select from always returns an array, even if its one\n  // console.log(usersWithUsername[0]);\n\n  if (usersWithUsername.length === 0) return usersWithUsername;\n  const passwordMatches = await argon2.verify(usersWithUsername[0].password_hash, password); //this returns boolean\n\n  if (passwordMatches) {\n    return usersWithUsername;\n  } else {\n    return [];\n  }\n}\nexport async function insertUser(username, passwordHash) {\n  return sql`\n    INSERT INTO users (username, password_hash) VALUES (${username}, ${passwordHash})\n  `;\n}\nexport async function selectSessionByToken(token) {\n  return sql`\n    SELECT * FROM sessions WHERE token = ${token}\n  `;\n}\nexport async function deleteSessionByToken(token) {\n  return sql`\n    DELETE FROM sessions WHERE token = ${token}\n  `;\n}\nexport async function insertSession(userId, token) {\n  return sql`\n    INSERT INTO sessions (user_id, token) VALUES (${userId}, ${token})\n  `;\n}\nexport async function insertJourney(startDate, endDate, token) {\n  const search = await sql`\n    SELECT user_id FROM sessions WHERE token = ${token}\n  `;\n  console.log(search);\n  const userId = search[0].user_id;\n  return sql`\n    INSERT INTO journeys (start_date, end_date, user_id) VALUES (${startDate}, ${endDate}, ${userId}) RETURNING id, start_date, end_date, user_id\n  `;\n}\n\nfunction getRandomItem(arr) {\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\nexport async function insertEntries(tagIds, journeyId) {\n  // selectedTags shows me places_id column based tags_id\n  const placesAndTags = await sql`\n    SELECT places_id, tags_id FROM places_tags WHERE tags_id IN (${tagIds})\n  `;\n  console.log('placesandTags:', placesAndTags);\n  console.log('tagIds', tagIds); // tag gives a random number from the places_id column\n\n  const selectedPlacesAndTags = [];\n  tagIds.forEach(tagId => {\n    // these are the placesIds based on the tagId\n    const placesByTag = placesAndTags.filter(placeAndTag => {\n      return placeAndTag.tags_id === Number(tagId);\n    });\n    const selectedPlaceAndTag = getRandomItem(placesByTag);\n    selectedPlacesAndTags.push(selectedPlaceAndTag);\n    console.log('selectedplaces:', selectedPlacesAndTags);\n  });\n  console.log('selectedplaces:', selectedPlacesAndTags);\n  const places = selectedPlacesAndTags.map(place_id => {\n    console.log(place_id);\n    return place_id.places_id;\n  });\n  console.log('places', places);\n  const tagArray = await sql`\n    SELECT name, address, image, description FROM places WHERE id IN (${places}) \n  `;\n  console.log('tagArray', tagArray);\n  await sql`\n    INSERT INTO entriesTags (journey_id, place_id)\n    SELECT ${journeyId}, x\n      FROM unnest(ARRAY[${places}]) x\n  `;\n  return tagArray;\n}\nexport async function sessionsJoinENtries(token) {\n  const trip = await sql`\n    SELECT \n      journeys.id as journey_id\n    FROM \n      sessions,\n      users,\n      journeys\n    WHERE \n      sessions.token = ${token} AND\n      users.id = sessions.user_id AND\n      journeys.user_id = users.id;\n  `;\n  console.log('meme', trip);\n  console.log(token);\n  return trip;\n}\nexport async function personalizedPlan() {\n  const plan = await sql`\n    SELECT \n      places.name,  \n      places.address, \n      places.image,\n      places.description \n    FROM \n      places,\n      entriesTags \n    WHERE \n      places.id = entriesTags.places_id\n  `;\n  return plan;\n} // export async function personalizedPlan(places) {\n//   const plan = await sql`\n//     SELECT * FROM places WHERE\n//   `;\n// }\n// export async function selectUserByUsername(username, password) {\n//   const usersWithUsername = await sql`\n//   SELECT * FROM users WHERE username = ${username}\n//   `; //select from always returns an array, even if its one\n//   // console.log(usersWithUsername[0]);\n//   if (usersWithUsername.length === 0) return usersWithUsername;\n//   const passwordMatches = await argon2.verify(\n//     usersWithUsername[0].password_hash,\n//     password,\n//   ); //this returns boolean\n//   if (passwordMatches) {\n//     return usersWithUsername;\n//   } else {\n//     return [];\n//   }\n// }","map":{"version":3,"sources":["/Users/gabrielasanchez/projects/wolfis-trip/db.js"],"names":["require","config","argon2","postgres","sql","getPlaces","places","selectUserByUsername","username","password","usersWithUsername","length","passwordMatches","verify","password_hash","insertUser","passwordHash","selectSessionByToken","token","deleteSessionByToken","insertSession","userId","insertJourney","startDate","endDate","search","console","log","user_id","getRandomItem","arr","Math","floor","random","insertEntries","tagIds","journeyId","placesAndTags","selectedPlacesAndTags","forEach","tagId","placesByTag","filter","placeAndTag","tags_id","Number","selectedPlaceAndTag","push","map","place_id","places_id","tagArray","sessionsJoinENtries","trip","personalizedPlan","plan"],"mappings":"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","sourcesContent":["require('dotenv').config();\n\nconst argon2 = require('argon2');\nconst postgres = require('postgres');\nconst sql = postgres();\n\nexport async function getPlaces() {\n  const places = await sql`\n    select * from places\n  `;\n  return places;\n}\n\nexport async function selectUserByUsername(username, password) {\n  const usersWithUsername = await sql`\n  SELECT * FROM users WHERE username = ${username}\n  `; //select from always returns an array, even if its one\n  // console.log(usersWithUsername[0]);\n  if (usersWithUsername.length === 0) return usersWithUsername;\n  const passwordMatches = await argon2.verify(\n    usersWithUsername[0].password_hash,\n    password,\n  ); //this returns boolean\n  if (passwordMatches) {\n    return usersWithUsername;\n  } else {\n    return [];\n  }\n}\n\nexport async function insertUser(username, passwordHash) {\n  return sql`\n    INSERT INTO users (username, password_hash) VALUES (${username}, ${passwordHash})\n  `;\n}\n\nexport async function selectSessionByToken(token) {\n  return sql`\n    SELECT * FROM sessions WHERE token = ${token}\n  `;\n}\n\nexport async function deleteSessionByToken(token) {\n  return sql`\n    DELETE FROM sessions WHERE token = ${token}\n  `;\n}\n\nexport async function insertSession(userId, token) {\n  return sql`\n    INSERT INTO sessions (user_id, token) VALUES (${userId}, ${token})\n  `;\n}\n\nexport async function insertJourney(startDate, endDate, token) {\n  const search = await sql`\n    SELECT user_id FROM sessions WHERE token = ${token}\n  `;\n  console.log(search);\n\n  const userId = search[0].user_id;\n\n  return sql`\n    INSERT INTO journeys (start_date, end_date, user_id) VALUES (${startDate}, ${endDate}, ${userId}) RETURNING id, start_date, end_date, user_id\n  `;\n}\nfunction getRandomItem(arr) {\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\nexport async function insertEntries(tagIds, journeyId) {\n  // selectedTags shows me places_id column based tags_id\n  const placesAndTags = await sql`\n    SELECT places_id, tags_id FROM places_tags WHERE tags_id IN (${tagIds})\n  `;\n  console.log('placesandTags:', placesAndTags);\n  console.log('tagIds', tagIds);\n\n  // tag gives a random number from the places_id column\n  const selectedPlacesAndTags = [];\n  tagIds.forEach((tagId) => {\n    // these are the placesIds based on the tagId\n    const placesByTag = placesAndTags.filter((placeAndTag) => {\n      return placeAndTag.tags_id === Number(tagId);\n    });\n    const selectedPlaceAndTag = getRandomItem(placesByTag);\n    selectedPlacesAndTags.push(selectedPlaceAndTag);\n    console.log('selectedplaces:', selectedPlacesAndTags);\n  });\n\n  console.log('selectedplaces:', selectedPlacesAndTags);\n  const places = selectedPlacesAndTags.map((place_id) => {\n    console.log(place_id);\n    return place_id.places_id;\n  });\n\n  console.log('places', places);\n  const tagArray = await sql`\n    SELECT name, address, image, description FROM places WHERE id IN (${places}) \n  `;\n\n  console.log('tagArray', tagArray);\n\n  await sql`\n    INSERT INTO entriesTags (journey_id, place_id)\n    SELECT ${journeyId}, x\n      FROM unnest(ARRAY[${places}]) x\n  `;\n\n  return tagArray;\n}\n\nexport async function sessionsJoinENtries(token) {\n  const trip = await sql`\n    SELECT \n      journeys.id as journey_id\n    FROM \n      sessions,\n      users,\n      journeys\n    WHERE \n      sessions.token = ${token} AND\n      users.id = sessions.user_id AND\n      journeys.user_id = users.id;\n  `;\n  console.log('meme', trip);\n  console.log(token);\n  return trip;\n}\n\nexport async function personalizedPlan() {\n  const plan = await sql`\n    SELECT \n      places.name,  \n      places.address, \n      places.image,\n      places.description \n    FROM \n      places,\n      entriesTags \n    WHERE \n      places.id = entriesTags.places_id\n  `;\n  return plan;\n}\n\n// export async function personalizedPlan(places) {\n//   const plan = await sql`\n//     SELECT * FROM places WHERE\n//   `;\n// }\n// export async function selectUserByUsername(username, password) {\n//   const usersWithUsername = await sql`\n//   SELECT * FROM users WHERE username = ${username}\n//   `; //select from always returns an array, even if its one\n//   // console.log(usersWithUsername[0]);\n//   if (usersWithUsername.length === 0) return usersWithUsername;\n//   const passwordMatches = await argon2.verify(\n//     usersWithUsername[0].password_hash,\n//     password,\n//   ); //this returns boolean\n//   if (passwordMatches) {\n//     return usersWithUsername;\n//   } else {\n//     return [];\n//   }\n// }\n"]},"metadata":{},"sourceType":"module"}