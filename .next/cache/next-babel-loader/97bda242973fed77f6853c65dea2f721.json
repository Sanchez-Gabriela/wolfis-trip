{"ast":null,"code":"require('dotenv').config();\n\nconst argon2 = require('argon2');\n\nconst postgres = require('postgres');\n\nconst sql = postgres();\nexport async function getPlaces() {\n  const places = await sql`\n    select * from places\n  `;\n  return places;\n}\nexport async function selectUserByUsername(username, password) {\n  const usersWithUsername = await sql`\n  SELECT * FROM users WHERE username = ${username}\n  `; //select from always returns an array, even if its one\n  // console.log(usersWithUsername[0]);\n\n  if (usersWithUsername.length === 0) return usersWithUsername;\n  const passwordMatches = await argon2.verify(usersWithUsername[0].password_hash, password); //this returns boolean\n\n  if (passwordMatches) {\n    return usersWithUsername;\n  } else {\n    return [];\n  }\n}\nexport async function insertUser(username, passwordHash) {\n  return sql`\n    INSERT INTO users (username, password_hash) VALUES (${username}, ${passwordHash})\n  `;\n}\nexport async function selectSessionByToken(token) {\n  return sql`\n    SELECT * FROM sessions WHERE token = ${token}\n  `;\n}\nexport async function deleteSessionByToken(token) {\n  return sql`\n    DELETE FROM sessions WHERE token = ${token}\n  `;\n}\nexport async function insertSession(userId, token) {\n  return sql`\n    INSERT INTO sessions (user_id, token) VALUES (${userId}, ${token})\n  `;\n}\nexport async function insertJourney(startDate, endDate, token) {\n  const search = await sql`\n    SELECT user_id FROM sessions WHERE token = ${token}\n  `;\n  console.log(search);\n  const userId = search[0].user_id;\n  return sql`\n    INSERT INTO journeys (start_date, end_date, user_id) VALUES (${startDate}, ${endDate}, ${userId}) RETURNING id, start_date, end_date, user_id\n  `;\n}\n\nfunction getRandomItem(arr) {\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\nexport async function insertEntries(tagIds, journeyId) {\n  // selectedTags shows me a places_id column where tags_id is 7 for all of them\n  const placesAndTags = await sql`\n    SELECT places_id, tags_id FROM places_tags WHERE tags_id IN (${tagIds})\n  `;\n  console.log('karl', placesAndTags); // tag gives a random number from the places_id column\n\n  const selectedPlacesAndTags = [];\n  tagIds.forEach(tagId => {\n    // these are the placesIds based on the tagId\n    const placesByTag = placesAndTags.filter(placeAndTag => {\n      return placeAndTag.tags_id === Number(tagId);\n    });\n    const selectedPlaceAndTag = getRandomItem(placesByTag);\n    selectedPlacesAndTags.push(selectedPlaceAndTag);\n  });\n  console.log('I need places_id', selectedPlacesAndTags); // it works\n\n  const tagArray = await sql`\n    SELECT name, address, image, description FROM places WHERE places_id IN (${selectedPlacesAndTags})\n  `;\n  console.log('tagArray', tagArray);\n  return sql`\n    INSERT INTO entries (journey_id, place_id) VALUES (${journeyId}, ${tag}) \n  `;\n}","map":{"version":3,"sources":["/Users/gabrielasanchez/projects/wolfis-trip/db.js"],"names":["require","config","argon2","postgres","sql","getPlaces","places","selectUserByUsername","username","password","usersWithUsername","length","passwordMatches","verify","password_hash","insertUser","passwordHash","selectSessionByToken","token","deleteSessionByToken","insertSession","userId","insertJourney","startDate","endDate","search","console","log","user_id","getRandomItem","arr","Math","floor","random","insertEntries","tagIds","journeyId","placesAndTags","selectedPlacesAndTags","forEach","tagId","placesByTag","filter","placeAndTag","tags_id","Number","selectedPlaceAndTag","push","tagArray","tag"],"mappings":"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","sourcesContent":["require('dotenv').config();\n\nconst argon2 = require('argon2');\nconst postgres = require('postgres');\nconst sql = postgres();\n\nexport async function getPlaces() {\n  const places = await sql`\n    select * from places\n  `;\n  return places;\n}\n\nexport async function selectUserByUsername(username, password) {\n  const usersWithUsername = await sql`\n  SELECT * FROM users WHERE username = ${username}\n  `; //select from always returns an array, even if its one\n  // console.log(usersWithUsername[0]);\n  if (usersWithUsername.length === 0) return usersWithUsername;\n  const passwordMatches = await argon2.verify(\n    usersWithUsername[0].password_hash,\n    password,\n  ); //this returns boolean\n  if (passwordMatches) {\n    return usersWithUsername;\n  } else {\n    return [];\n  }\n}\n\nexport async function insertUser(username, passwordHash) {\n  return sql`\n    INSERT INTO users (username, password_hash) VALUES (${username}, ${passwordHash})\n  `;\n}\n\nexport async function selectSessionByToken(token) {\n  return sql`\n    SELECT * FROM sessions WHERE token = ${token}\n  `;\n}\n\nexport async function deleteSessionByToken(token) {\n  return sql`\n    DELETE FROM sessions WHERE token = ${token}\n  `;\n}\n\nexport async function insertSession(userId, token) {\n  return sql`\n    INSERT INTO sessions (user_id, token) VALUES (${userId}, ${token})\n  `;\n}\n\nexport async function insertJourney(startDate, endDate, token) {\n  const search = await sql`\n    SELECT user_id FROM sessions WHERE token = ${token}\n  `;\n  console.log(search);\n\n  const userId = search[0].user_id;\n\n  return sql`\n    INSERT INTO journeys (start_date, end_date, user_id) VALUES (${startDate}, ${endDate}, ${userId}) RETURNING id, start_date, end_date, user_id\n  `;\n}\nfunction getRandomItem(arr) {\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\nexport async function insertEntries(tagIds, journeyId) {\n  // selectedTags shows me a places_id column where tags_id is 7 for all of them\n  const placesAndTags = await sql`\n    SELECT places_id, tags_id FROM places_tags WHERE tags_id IN (${tagIds})\n  `;\n  console.log('karl', placesAndTags);\n  // tag gives a random number from the places_id column\n  const selectedPlacesAndTags = [];\n  tagIds.forEach((tagId) => {\n    // these are the placesIds based on the tagId\n    const placesByTag = placesAndTags.filter((placeAndTag) => {\n      return placeAndTag.tags_id === Number(tagId);\n    });\n    const selectedPlaceAndTag = getRandomItem(placesByTag);\n    selectedPlacesAndTags.push(selectedPlaceAndTag);\n  });\n\n  console.log('I need places_id', selectedPlacesAndTags);\n  // it works\n  const tagArray = await sql`\n    SELECT name, address, image, description FROM places WHERE places_id IN (${selectedPlacesAndTags})\n  `;\n\n  console.log('tagArray', tagArray);\n\n  return sql`\n    INSERT INTO entries (journey_id, place_id) VALUES (${journeyId}, ${tag}) \n  `;\n}\n"]},"metadata":{},"sourceType":"module"}